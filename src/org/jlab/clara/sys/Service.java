/*
 * Copyright (C) 2015. Jefferson Lab, CLARA framework (JLAB). All Rights Reserved.
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for educational, research, and not-for-profit purposes,
 * without fee and without a signed licensing agreement.
 *
 * Author Vardan Gyurjyan
 * Department of Experimental Nuclear Physics, Jefferson Lab.
 *
 * IN NO EVENT SHALL JLAB BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
 * THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF JLAB HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * JLAB SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE. THE CLARA SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
 * HEREUNDER IS PROVIDED "AS IS". JLAB HAS NO OBLIGATION TO PROVIDE MAINTENANCE,
 * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */

package org.jlab.clara.sys;

import com.google.protobuf.ByteString;
import org.jlab.clara.base.CBase;
import org.jlab.clara.base.CException;
import org.jlab.clara.util.*;
import org.jlab.coda.xmsg.core.xMsgConstants;
import org.jlab.coda.xmsg.core.xMsgUtil;
import org.jlab.coda.xmsg.data.xMsgD;
import org.jlab.coda.xmsg.excp.xMsgException;

import java.io.IOException;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * <p>
 *     Service creates a memory mapped file,
 *     i.e. named shared memory in the virtual
 *     memory space of the node.
 *
 *     At the constructor stage memory mapped
 *     file will be created wit the name:
 *     <b>jclara_containerName_serviceEngineName_uniqueId</b>
 *
 *     Unique ID will be generated by calling singleton
 *     object getUniqueId method. THis singleton class can
 *     be part of the Clara base class.
 *
 *     If receiving service (based on the c_composition)
 *     is local (i.e. on the same node) xMsg publish
 *     will have a construct:
 *     <b>topic, sender, String = memoryMappedFileName</b>
 *     otherwise if service next in the chain is remote,
 *     xMsg publish will have a construct:
 *     <b>topic, sender, xMsgData_object</b>
 * </p>
 *
 * @author gurjyan
 * @version 1.x
 * @since 1/30/15
 */
public class Service extends CBase {


    // Already recorded (previous) composition
    private String
            p_composition = xMsgConstants.UNDEFINED.getStringValue();

    // user provided engine class container class name
    private String
            engine_class_name = xMsgConstants.UNDEFINED.getStringValue();

    // Engine instantiated object
    private ACEngine
            engine_object = null;

    // The dynamic (updated for every request) repository/map
    // (mapped by the composition) of input-linked service
    // names that are required to be logically AND-ed
    private HashMap<String, List<String>>
            in_and_name_list = new HashMap<>();

    // The dynamic ( updated for every request) repository/map
    // (mapped by the composition string) of input-linked service
    // data that are required to be logically AND-ed
    private HashMap<String, HashMap<String,EngineData>>
            in_and_data_list = new HashMap<>();

    // Local map of input-linked services for every
    // composition in multi-composition application.
    // Note: by design compositions are separated by ";"
    private HashMap<String, List<String>>
            in_links = new HashMap<>();

    // Local map of output-linked services for every
    // composition in multi-composition application.
    private HashMap<String, List<String>>
            out_links = new HashMap<>();

    // key in the shared memory map of DPE to
    // locate this service resulting data object
    private String
            sharedMemoryKey = xMsgConstants.UNDEFINED.getStringValue();

    // Simple average of the service engine
    // execution times ove all received requests
    private long _avEngineExecutionTime;

    // Number of received requests to this service.
    // Note: common for different compositions
    private long _numberOfRequests;


    /**
     * <p>
     * Constructor
     * </p>
     *
     * @param packageName service engine package name
     * @param name   Clara service canonical name
     *               (such as dep:container:engine)
     * @param sharedMemoryKey key in the shared memory map of DPE to
     *                        locate this service resulting data object
     * @param feHost front-end host name. This is the host that holds
     *               centralized registration database.
     * @throws xMsgException
     */
    public Service(String packageName,
                   String name,
                   String sharedMemoryKey,
                   String feHost)
            throws xMsgException,
            CException,
            SocketException,
            IllegalAccessException,
            InstantiationException,
            ClassNotFoundException {
        super(feHost);
        setName(name);

        this.sharedMemoryKey = sharedMemoryKey;

        this.engine_class_name = packageName+"."+CUtility.getEngineName(getName());

        // Dynamic loading of the Clara engine class
        // Note: using system class loader
        CClassLoader cl = new CClassLoader(ClassLoader.getSystemClassLoader());
        engine_object = cl.load(engine_class_name);


        // Create a socket connections
        // to the local dpe proxy
        connect();

        System.out.println("ObjectPool + " + getName());

    }

    /**
     * <p>
     * Constructor
     * </p>
     *
     * @param packageName service engine package name
     * @param name Clara service canonical name
     *             (such as dep:container:engine)
     * @param sharedMemoryKey key in the shared memory map of DPE to
     *                        locate this service resulting data object
     * @throws xMsgException
     */
    public Service(String packageName,
                   String name,
                   String sharedMemoryKey)
            throws xMsgException,
            CException,
            SocketException,
            IllegalAccessException,
            InstantiationException,
            ClassNotFoundException {
        super();
        setName(name);
        this.sharedMemoryKey = sharedMemoryKey;
        this.engine_class_name = packageName+"."+CUtility.getEngineName(getName());

        // Dynamic loading of the Clara engine class
        // Note: using system class loader
        Class exampleClass = Class.forName(engine_class_name);
        engine_object = (ACEngine)exampleClass.newInstance();

        // Create a socket connections
        // to the local dpe proxy
        connect();

        System.out.println("\n ObjectPool: add service = " + getName());

    }

    /**
     * Service configure method
     *
     * @param objectPool reference to the object pool that is
     *                   used to put back the object after the execution
     * @param dataType describes the type of the data object (string or xMsgData)
     * @param data     xMsg envelope payload
     * @param syncReceiverName the name of the sync requester
     * @param configureCountDown the remaining instances to be configured
     *
     * @throws CException
     * @throws xMsgException
     * @throws InterruptedException
     */
    public void configure(LinkedBlockingQueue<Service> objectPool,
                          String dataType,
                          Object data,
                          String syncReceiverName,
                          AtomicInteger configureCountDown)
            throws CException,
            xMsgException,
            InterruptedException,
            IOException,
            ClassNotFoundException {

        xMsgD.Data.Builder inData = null;

        Object userData;

        EngineData engineInData = null;

        String sharedMemoryPointer;

        if (dataType.equals(xMsgConstants.ENVELOPE_DATA_TYPE_STRING.getStringValue())) {
            // Note in this case we do not de-serialization, because
            // data is in the shared memory and un-serialized
            sharedMemoryPointer = (String) data;

            // get inData from the shared memory
            inData = Dpe.sharedMemory.get(sharedMemoryPointer);

            //user data may also be un-serialized
            userData = Dpe.sharedDataObject.get(sharedMemoryPointer);

            switch(inData.getDataType()){
                case T_VLSINT32:
                    engineInData = new EngineData(inData.getVLSINT32(), inData);
                    break;
                case T_VLSINT64:
                    engineInData = new EngineData(inData.getVLSINT64(), inData);
                    break;
                case T_FLSINT32:
                    engineInData = new EngineData(inData.getFLSINT32(), inData);
                    break;
                case T_FLSINT64:
                    engineInData = new EngineData(inData.getFLSINT64(), inData);
                    break;
                case T_FLOAT:
                    engineInData = new EngineData(inData.getFLOAT(), inData);
                    break;
                case T_DOUBLE:
                    engineInData = new EngineData(inData.getDOUBLE(), inData);
                    break;
                case T_STRING:
                    engineInData = new EngineData(inData.getSTRING(), inData);
                    break;
                case T_BYTES:
                    engineInData = new EngineData(inData.getBYTES().toByteArray(), inData);
                    break;
                case T_VLSINT32A:
                    engineInData = new EngineData(inData.getVLSINT32AList(), inData);
                    break;
                case T_VLSINT64A:
                    engineInData = new EngineData(inData.getVLSINT64AList(), inData);
                    break;
                case T_FLSINT32A:
                    engineInData = new EngineData(inData.getFLSINT32AList(), inData);
                    break;
                case T_FLSINT64A:
                    engineInData = new EngineData(inData.getFLSINT64AList(), inData);
                    break;
                case T_FLOATA:
                    engineInData = new EngineData(inData.getFLOATAList(), inData);
                    break;
                case T_DOUBLEA:
                    engineInData = new EngineData(inData.getDOUBLEAList(), inData);
                    break;
                case T_STRINGA:
                    engineInData = new EngineData(inData.getSTRINGAList(), inData);
                    break;
                case T_PAYLOAD:
                    break;
                case T_EXTERNAL_OBJECT:
                    engineInData = new EngineData(userData, inData);
                    break;
            }

        } else if (dataType.equals(xMsgConstants.ENVELOPE_DATA_TYPE_XMSGDATA.getStringValue())) {

            // Note. here we need to do de-serialization
            inData = (xMsgD.Data.Builder) data;

            switch (inData.getDataType()) {
                case T_VLSINT32:
                    engineInData = new EngineData(inData.getVLSINT32(), inData);
                    break;
                case T_VLSINT64:
                    engineInData = new EngineData(inData.getVLSINT64(), inData);
                    break;
                case T_FLSINT32:
                    engineInData = new EngineData(inData.getFLSINT32(), inData);
                    break;
                case T_FLSINT64:
                    engineInData = new EngineData(inData.getFLSINT64(), inData);
                    break;
                case T_FLOAT:
                    engineInData = new EngineData(inData.getFLOAT(), inData);
                    break;
                case T_DOUBLE:
                    engineInData = new EngineData(inData.getDOUBLE(), inData);
                    break;
                case T_STRING:
                    engineInData = new EngineData(inData.getSTRING(), inData);
                    break;
                case T_BYTES:
                    // Using de-serialization of the Clara supported user formats
                    switch (inData.getByteArrayType()) {
                        case JOBJECT:
                            Object usrObj = CUtility.deSerialize(inData.getBYTES().toByteArray());
                            engineInData = new EngineData(usrObj, inData);
                            break;
                        case NETCDF:
                            break;
                        case HDF:
                            break;
                        case EVIO:
                            break;
                    }
                    break;
                case T_VLSINT32A:
                    engineInData = new EngineData(inData.getVLSINT32AList(), inData);
                    break;
                case T_VLSINT64A:
                    engineInData = new EngineData(inData.getVLSINT64AList(), inData);
                    break;
                case T_FLSINT32A:
                    engineInData = new EngineData(inData.getFLSINT32AList(), inData);
                    break;
                case T_FLSINT64A:
                    engineInData = new EngineData(inData.getFLSINT64AList(), inData);
                    break;
                case T_FLOATA:
                    engineInData = new EngineData(inData.getFLOATAList(), inData);
                    break;
                case T_DOUBLEA:
                    engineInData = new EngineData(inData.getDOUBLEAList(), inData);
                    break;
                case T_STRINGA:
                    engineInData = new EngineData(inData.getSTRINGAList(), inData);
                    break;
                case T_PAYLOAD:
                    break;
                case T_EXTERNAL_OBJECT:
                    break;

            }
        }

        if(inData==null)throw new CException("unknown data type");
        // check to see if this is a configure request
        if (inData.getAction().equals(xMsgD.Data.ControlAction.CONFIGURE)){
            engine_object.configure(engineInData);

            // If this is a sync request send done to the requester
            if(!syncReceiverName.equals(xMsgConstants.UNDEFINED.getStringValue())){
                int remainingIntances = configureCountDown.decrementAndGet();
                if (remainingIntances == 0) {
                    String dpeName = CUtility.getDpeName(syncReceiverName);
                    genericSend(dpeName, syncReceiverName, xMsgConstants.DONE.getStringValue());
                }
            }
        }
        // return this object to the pool
        objectPool.put(this);
    }

    /**
     * Service process method. Note that configure
     * will never be execute within this method.
     *
     * @param config CServiceConfig object for the service. Contains information
     *               to broadcast done and/or data
     * @param objectPool reference to the object pool that is
     *                   used to put back the object after the execution
     * @param dataType describes the type of the data object (string or xMsgData)
     * @param data     xMsg envelope payload
     * @param syncReceiverName the name of the sync requester
     * @param id request id
     *
     * @throws CException
     * @throws xMsgException
     * @throws InterruptedException
     */
    public void process(CServiceSysConfig config, LinkedBlockingQueue<Service> objectPool,
                        String dataType,
                        Object data,
                        String syncReceiverName,
                        int id)
            throws CException,
            xMsgException,
            IOException,
            InterruptedException,
            ClassNotFoundException {

        xMsgD.Data.Builder inData = null;

        Object userData;

        EngineData engineInData = null;

        String sharedMemoryPointer;

        // Increment request count in the sysConfig object
        config.addRequest();

        // Variables to measure service
        // engine execution time
        long startTime;
        long endTime;

        if (dataType.equals(xMsgConstants.ENVELOPE_DATA_TYPE_STRING.getStringValue())) {
            sharedMemoryPointer = (String) data;

            // get inData from the shared memory
            inData = Dpe.sharedMemory.get(sharedMemoryPointer);

            //user data may also be un-serialized
            userData = Dpe.sharedDataObject.get(sharedMemoryPointer);

            switch(inData.getDataType()){
                case T_VLSINT32:
                    engineInData = new EngineData(inData.getVLSINT32(), inData);
                    break;
                case T_VLSINT64:
                    engineInData = new EngineData(inData.getVLSINT64(), inData);
                    break;
                case T_FLSINT32:
                    engineInData = new EngineData(inData.getFLSINT32(), inData);
                    break;
                case T_FLSINT64:
                    engineInData = new EngineData(inData.getFLSINT64(), inData);
                    break;
                case T_FLOAT:
                    engineInData = new EngineData(inData.getFLOAT(), inData);
                    break;
                case T_DOUBLE:
                    engineInData = new EngineData(inData.getDOUBLE(), inData);
                    break;
                case T_STRING:
                    engineInData = new EngineData(inData.getSTRING(), inData);
                    break;
                case T_BYTES:
                    engineInData = new EngineData(inData.getBYTES().toByteArray(), inData);
                    break;
                case T_VLSINT32A:
                    engineInData = new EngineData(inData.getVLSINT32AList(), inData);
                    break;
                case T_VLSINT64A:
                    engineInData = new EngineData(inData.getVLSINT64AList(), inData);
                    break;
                case T_FLSINT32A:
                    engineInData = new EngineData(inData.getFLSINT32AList(), inData);
                    break;
                case T_FLSINT64A:
                    engineInData = new EngineData(inData.getFLSINT64AList(), inData);
                    break;
                case T_FLOATA:
                    engineInData = new EngineData(inData.getFLOATAList(), inData);
                    break;
                case T_DOUBLEA:
                    engineInData = new EngineData(inData.getDOUBLEAList(), inData);
                    break;
                case T_STRINGA:
                    engineInData = new EngineData(inData.getSTRINGAList(), inData);
                    break;
                case T_PAYLOAD:
                    break;
                case T_EXTERNAL_OBJECT:
                    engineInData = new EngineData(userData, inData);
                    break;
            }

        } else if (dataType.equals(xMsgConstants.ENVELOPE_DATA_TYPE_XMSGDATA.getStringValue())) {

            // Note. here we need to do de-serialization
            inData = (xMsgD.Data.Builder) data;

            switch (inData.getDataType()) {
                case T_VLSINT32:
                    engineInData = new EngineData(inData.getVLSINT32(), inData);
                    break;
                case T_VLSINT64:
                    engineInData = new EngineData(inData.getVLSINT64(), inData);
                    break;
                case T_FLSINT32:
                    engineInData = new EngineData(inData.getFLSINT32(), inData);
                    break;
                case T_FLSINT64:
                    engineInData = new EngineData(inData.getFLSINT64(), inData);
                    break;
                case T_FLOAT:
                    engineInData = new EngineData(inData.getFLOAT(), inData);
                    break;
                case T_DOUBLE:
                    engineInData = new EngineData(inData.getDOUBLE(), inData);
                    break;
                case T_STRING:
                    engineInData = new EngineData(inData.getSTRING(), inData);
                    break;
                case T_BYTES:
                    // Using de-serialization of the Clara supported user formats
                    switch (inData.getByteArrayType()) {
                        case JOBJECT:
                            Object usrObj = CUtility.deSerialize(inData.getBYTES().toByteArray());
                            engineInData = new EngineData(usrObj, inData);
                            break;
                        case NETCDF:
                            break;
                        case HDF:
                            break;
                        case EVIO:
                            break;
                    }
                    break;
                case T_VLSINT32A:
                    engineInData = new EngineData(inData.getVLSINT32AList(), inData);
                    break;
                case T_VLSINT64A:
                    engineInData = new EngineData(inData.getVLSINT64AList(), inData);
                    break;
                case T_FLSINT32A:
                    engineInData = new EngineData(inData.getFLSINT32AList(), inData);
                    break;
                case T_FLSINT64A:
                    engineInData = new EngineData(inData.getFLSINT64AList(), inData);
                    break;
                case T_FLOATA:
                    engineInData = new EngineData(inData.getFLOATAList(), inData);
                    break;
                case T_DOUBLEA:
                    engineInData = new EngineData(inData.getDOUBLEAList(), inData);
                    break;
                case T_STRINGA:
                    engineInData = new EngineData(inData.getSTRINGAList(), inData);
                    break;
                case T_PAYLOAD:
                    break;
                case T_EXTERNAL_OBJECT:
                    break;

            }
        }

        if(inData==null)throw new CException("unknown data type");

        String c_composition = inData.getComposition();
        String senderService = inData.getSender();


        if (inData.getAction().equals(xMsgD.Data.ControlAction.EXECUTE)) {

            long execTime = 0;

            if (!c_composition.equals(p_composition)) {
                // analyze composition
                analyzeComposition(c_composition);
                p_composition = c_composition;
            }

            // Execute service engine
            EngineData service_result = null;

            for (String com : in_links.keySet()) {

                // find a sub_composition that sender
                // service is listed as a an input service
                if (com.contains(senderService)) {

                    // Find if the data from this input service
                    // is required to be logically ANDed with
                    // other input service.
                    // Go over all sub_compositions that require
                    // logical AND of inputs
                    if (in_and_name_list.containsKey(com)) {

                        // Get that sub composition and check against
                        // the received service name the list of service
                        // that are required to be logically ANDed
                        for (String ser : in_and_name_list.get(com)) {
                            if (ser.equals(senderService)) {
                                if (in_and_data_list.containsKey(com)) {
                                    HashMap<String, EngineData> dm = in_and_data_list.get(com);
                                    dm.put(senderService, engineInData);
                                } else {
                                    HashMap<String, EngineData> dm = new HashMap<>();
                                    dm.put(senderService, engineInData);
                                    in_and_data_list.put(com, dm);
                                }
                            }
                        }

                        // Now check the size of received data list
                        // with the required input name list.
                        // If equal we will execute the service.
                        if (in_and_name_list.get(com).size() == in_and_data_list.get(com).size()) {

                            List<EngineData> ddl = new ArrayList<>();

                            for (HashMap<String, EngineData> m : in_and_data_list.values()) {
                                for (EngineData d : m.values()) {
                                    ddl.add(d);
                                }
                            }
//                            System.out.println(senderService + ": Executing engine (logAND) = " + engine_class_name);
                            try {
                                // increment request count
                                _numberOfRequests++;
                                // get engine execution start time
                                startTime = System.nanoTime();

                                service_result = engine_object.execute_group(ddl);

                                // get engine execution end time
                                endTime = System.nanoTime();
                                // service engine execution time
                                execTime = endTime - startTime;
                                // Calculate a simple average for the execution time
                                _avEngineExecutionTime = (_avEngineExecutionTime + execTime)/ _numberOfRequests;

                            } catch (Throwable t){
                                report_error(t.getMessage(),3, engineInData.getId());
                                return;
                            }
                            // Clear inAnd data hash map for the satisfied composition
                            in_and_data_list.remove(com);
                            break;
                        }
                    } else {

                        // sub-composition does not require logical
                        // AND operations at the input of this service
//                        System.out.println(senderService + ": Executing engine = " + engine_class_name);
                        try{
                            // increment request count
                            _numberOfRequests++;
                            // get engine execution start time
                            startTime = System.nanoTime();

                            service_result = engine_object.execute(engineInData);

                            // get engine execution end time
                            endTime = System.nanoTime();
                            // service engine execution time
                            execTime = endTime - startTime;
                            // Calculate a simple average for the execution time
                            _avEngineExecutionTime = (_avEngineExecutionTime + execTime)/ _numberOfRequests;

                        } catch (Throwable t){
                            report_error(t.getMessage(),3, engineInData.getId());
                            return;
                        }
                        break;
                    }

                } else if (senderService.startsWith("orchestrator")) {
//                    System.out.println(" Orchestrator: Executing engine = " + engine_class_name);
                    try{
                        // increment request count
                        _numberOfRequests++;
                        // get engine execution start time
                        startTime = System.nanoTime();

                        service_result = engine_object.execute(engineInData);

                        // get engine execution end time
                        endTime = System.nanoTime();
                        // service engine execution time
                        execTime = endTime - startTime;
                        // Calculate a simple average for the execution time
                        _avEngineExecutionTime = (_avEngineExecutionTime + execTime)/ _numberOfRequests;

                    } catch (Throwable t){
                        report_error(t.getMessage(),3, engineInData.getId());
                        return;
                    }
                    break;
                }
            }

            xMsgD.Data.Builder res = xMsgD.Data.newBuilder();
            if(service_result==null){
                res.setDataGenerationStatus(xMsgD.Data.Severity.WARNING);
                res.setStatusText(getName()+ ": engine null output");
                res.setStatusSeverityId(1);
            } else {
                // update xMsgData transient data with the engine output result
                // Note: update all te relevant fields except data
                //       data will be serialized at the serviceSend
                res = buildOutTransit(inData, engineInData, execTime);
            }
            res.setSender(getName());

            // Negative id means the service just
            // simply passes the recorded id across
            if (res.getId() <= 0) res.setId(inData.getId());

            // Ensure the output data has the composition
            if (res.getComposition().isEmpty()) res.setComposition(c_composition);

            // Send service engine execution data
            serviceCompletionReport(config, res, engineInData);

            // If this is a sync request send data also to the requester
            if(!syncReceiverName.equals(xMsgConstants.UNDEFINED.getStringValue())){
                String dpeHost = CUtility.getDpeName(syncReceiverName);
                genericSend(dpeHost, syncReceiverName,res);
            }

            // If engine defines status error
            // or warning broadcast exception
            if(res.getDataGenerationStatus().equals(xMsgD.Data.Severity.ERROR)){
                report_error(res.getStatusText(),res.getStatusSeverityId(), res.getId());
            } else if(res.getDataGenerationStatus().equals(xMsgD.Data.Severity.WARNING)){
                report_warning(res.getStatusText(), res.getStatusSeverityId(), res.getId());
            }
        }

        // return this object to the pool
        objectPool.put(this);
    }


    private xMsgD.Data.Builder buildOutTransit(xMsgD.Data.Builder transit,
                                               EngineData engineData,
                                               long execTime) {


        switch (engineData.getDataType()) {
            case T_VLSINT32:
                transit.setDataType(xMsgD.Data.DType.T_VLSINT32);
                break;
            case T_VLSINT64:
                transit.setDataType(xMsgD.Data.DType.T_VLSINT64);
                break;
            case T_FLSINT32:
                transit.setDataType(xMsgD.Data.DType.T_FLSINT32);
                break;
            case T_FLSINT64:
                transit.setDataType(xMsgD.Data.DType.T_FLSINT64);
                break;
            case T_FLOAT:
                transit.setDataType(xMsgD.Data.DType.T_FLOAT);
                break;
            case T_DOUBLE:
                transit.setDataType(xMsgD.Data.DType.T_DOUBLE);
                break;
            case T_STRING:
                transit.setDataType(xMsgD.Data.DType.T_STRING);
                break;
            case JOBJECT:
                transit.setByteArrayType(xMsgD.Data.BAType.JOBJECT);
                break;
            case NETCDF:
                transit.setByteArrayType(xMsgD.Data.BAType.NETCDF);
                break;
            case HDF:
                transit.setByteArrayType(xMsgD.Data.BAType.HDF);
                break;
            case EVIO:
                transit.setByteArrayType(xMsgD.Data.BAType.EVIO);
                break;
            case T_VLSINT32A:
                transit.setDataType(xMsgD.Data.DType.T_VLSINT32A);
                break;
            case T_VLSINT64A:
                transit.setDataType(xMsgD.Data.DType.T_VLSINT64A);
                break;
            case T_FLSINT32A:
                transit.setDataType(xMsgD.Data.DType.T_FLSINT32A);
                break;
            case T_FLSINT64A:
                transit.setDataType(xMsgD.Data.DType.T_FLSINT64A);
                break;
            case T_FLOATA:
                transit.setDataType(xMsgD.Data.DType.T_FLOATA);
                break;
            case T_DOUBLEA:
                transit.setDataType(xMsgD.Data.DType.T_DOUBLEA);
                break;
            case T_STRINGA:
                transit.setDataType(xMsgD.Data.DType.T_STRINGA);
                break;
        }

        transit.setDataDescription(engineData.getDataDescription());
        transit.setDataVersion(engineData.getDataVersion());
        transit.setDataAuthorState(engineData.getState());
        transit.setDataGenerationStatus(engineData.getStatus());
        transit.setStatusSeverityId(engineData.getStatusSeverityId());
        transit.setStatusText(engineData.getStatusText());
        transit.setExecutionTime(execTime);

        return transit;
    }

    private void analyzeComposition(String composition) throws CException {
        // This is new routing (composition)  request
        // clear local input-link dictionary and output-links list
        in_links.clear();
        out_links.clear();
        in_and_name_list.clear();
        in_and_data_list.clear();

        // parse the new composition to find input and output
        // linked service names, but first check to see if we
        // have multiple parallel compositions (branching)

        if (composition.contains(";")){
            StringTokenizer st = new StringTokenizer(composition,";");
            while(st.hasMoreTokens()){
                String sub_comp = st.nextToken();
                if(sub_comp.contains(getName())){

                    List<String> il = parse_linked(getName(), sub_comp, 0);
                    in_links.put(sub_comp, il);

                    List<String> ol = parse_linked(getName(), sub_comp, 1);
                    out_links.put(sub_comp, ol);

                    if(is_log_and(getName(), sub_comp)){
                        in_and_name_list.put(sub_comp,il);
                    }
                }
            }
        } else {
            if(composition.contains(getName())){
                List<String> il = parse_linked(getName(), composition, 0);
                in_links.put(composition, il);

                List<String> ol = parse_linked(getName(), composition, 1);
                out_links.put(composition, ol);

                if(is_log_and(getName(), composition)){
                    in_and_name_list.put(composition,il);
                }
            }
        }


    }

    private void serviceCompletionReport(CServiceSysConfig config,
                                         xMsgD.Data.Builder data,
                                         EngineData engineData)
            throws xMsgException, IOException, CException {

        // External broadcast data
        if (config.isDataRequest()){
            report_data(data, data.getDataGenerationStatus().name(),data.getStatusSeverityId());
            config.resetDataRequestCount();
        }

        // External done broadcasting
        if (config.isDoneRequest()) {
            report_done(data.getId());
            config.resetDoneRequestCount();
        }

        // Send to all output-linked services.
        // Note: multiple sub compositions
        for (List<String> ls:out_links.values()){
            for(String ss:ls) {
                if (CUtility.isRemoteService(ss)) {
                    // Here we need to serialize data
                    switch (data.getDataType()) {
                        case T_VLSINT32:
                            data.setVLSINT32((Integer)engineData.getData());
                            break;
                        case T_VLSINT64:
                            data.setVLSINT64((Long)engineData.getData());
                            break;
                        case T_FLSINT32:
                            data.setFLSINT32((Integer) engineData.getData());
                            break;
                        case T_FLSINT64:
                            data.setFLSINT64((Long) engineData.getData());
                            break;
                        case T_FLOAT:
                            data.setFLOAT((Float)engineData.getData());
                            break;
                        case T_DOUBLE:
                            data.setDOUBLE((Double)engineData.getData());
                            break;
                        case T_STRING:
                            data.setSTRING((String)engineData.getData());
                            break;
                        case T_BYTES:
                            // Using serialization of the Clara supported user formats
                            switch (data.getByteArrayType()) {
                                case JOBJECT:
                                    byte[] sdata = CUtility.serialize(engineData.getData());
                                    data.setBYTES(ByteString.copyFrom(sdata));
                                    break;
                                case NETCDF:
                                    break;
                                case HDF:
                                    break;
                                case EVIO:
                                    break;
                            }
                            break;
                        case T_VLSINT32A:
                            for(int i=0; i<((List)engineData.getData()).size();i++ ) {
                                data.setVLSINT32A(i, (Integer) engineData.getData());
                            }
                            break;
                        case T_VLSINT64A:
                            for(int i=0; i<((List)engineData.getData()).size();i++ ) {
                                data.setVLSINT64A(i, (Long) engineData.getData());
                            }
                            break;
                        case T_FLSINT32A:
                            for(int i=0; i<((List)engineData.getData()).size();i++ ) {
                                data.setFLSINT32A(i, (Integer) engineData.getData());
                            }
                            break;
                        case T_FLSINT64A:
                            for(int i=0; i<((List)engineData.getData()).size();i++ ) {
                                data.setFLSINT64A(i, (Long) engineData.getData());
                            }
                            break;
                        case T_FLOATA:
                            for(int i=0; i<((List)engineData.getData()).size();i++ ) {
                                data.setFLOATA(i, (Float) engineData.getData());
                            }
                            break;
                        case T_DOUBLEA:
                            for(int i=0; i<((List)engineData.getData()).size();i++ ) {
                                data.setDOUBLEA(i, (Double) engineData.getData());
                            }
                            break;
                        case T_STRINGA:
                            for(int i=0; i<((List)engineData.getData()).size();i++ ) {
                                data.setSTRINGA(i, (String) engineData.getData());
                            }
                            break;
                        case T_PAYLOAD:
                            break;
                        case T_EXTERNAL_OBJECT:
                            break;
                    }
                    serviceSend(ss, data);
                } else {
                    // we do not need to serialize
                    Dpe.sharedDataObject.put(sharedMemoryKey,engineData.getData());
                    data.setDataType(xMsgD.Data.DType.T_EXTERNAL_OBJECT);

                    // copy data to the shared memory
                    Dpe.sharedMemory.put(sharedMemoryKey,data);
                    serviceSend(ss, sharedMemoryKey);
                }
            }
        }
    }

    /**
     * <p>
     *  Removes service xMsg registration
     * <p/>
     */
    public void remove_registration()
            throws xMsgException {

        removeSubscriberRegistration(getName(),
                xMsgUtil.getTopicDomain(getName()),
                xMsgUtil.getTopicSubject(getName()),
                xMsgUtil.getTopicType(getName()));
    }

    /**
     * <p>
     *    Broadcasts a xMsgData transient data
     *    containing an information-string to a
     *    topic = info:this_service_canonical_name.
     *    Note: that this will also send
     *    service engine execution average time.
     *
     * </p>
     * @param info_string content of the information
     */
    public void report_info(String info_string)
            throws xMsgException, SocketException {

        // build the xMsgData object
        xMsgD.Data.Builder db = xMsgD.Data.newBuilder();

        db.setSender(getName());
        db.setDataGenerationStatus(xMsgD.Data.Severity.INFO);
        db.setDataType(xMsgD.Data.DType.T_STRING);
        db.setSTRING(info_string);
        db.setExecutionTime(_avEngineExecutionTime);

        genericSend("localhost",
                xMsgConstants.INFO.getStringValue() + ":" +
                        getName(), db);
        if(!getFeHostName().equals(xMsgConstants.UNDEFINED.getStringValue())) {
            genericSend(getFeHostName(),
                    xMsgConstants.INFO.getStringValue() + ":" +
                            getName(), db);
        }
    }

    /**
     * <p>
     *    Broadcasts the average engine execution time to
     *    done:<service_name></service_name>, averageExecutionTime
     *
     * </p>
     */
    public void report_done(int id)
            throws xMsgException, SocketException {


        genericSend("localhost",
                xMsgConstants.DONE.getStringValue() + ":" +
                getName(), id + "?" + _avEngineExecutionTime);
        if(!getFeHostName().equals(xMsgConstants.UNDEFINED.getStringValue())) {
            genericSend(getFeHostName(),
                    xMsgConstants.DONE.getStringValue() + ":" +
                            getName(), id + "?" + _avEngineExecutionTime);
        }
    }

    /**
     * <p>
     *     Broadcasts a xMsgData transient data
     *     containing data generated by the engine,
     *     i.e. unaltered user engine output data.
     *     Severity = 1 is used to report data.
     *    Note: that the data contains service engine
     *    execution current/instantaneous time
     * </p>
     * @param data xMsgData object
     * @param report_type defines the topic to which data
     *                    will be broadcast. Only xMsgConstants
     *                    INFO/WARNING/ERROR are supported.
     */
    public void report_data(Object data,
                            String report_type,
                            int severity)
            throws xMsgException, SocketException {

        genericSend("localhost",
                xMsgConstants.DATA.getStringValue() + ":" +
                        getName() + ":" +
                        report_type+ ":" +
                        severity,
                data);
        if(!getFeHostName().equals(xMsgConstants.UNDEFINED.getStringValue())) {
            genericSend(getFeHostName(),
                    xMsgConstants.DATA.getStringValue() + ":" +
                            getName() + ":" +
                            report_type+ ":" +
                            severity,
                    data);

        }
    }

    /**
     * <p>
     *    Broadcasts a xMsgData transient data
     *    containing an warning-string to a
     *    topic = warning:severity:this_service_canonical_name
     *    Note: that this will also send
     *    service engine execution average time.
     *
     * </p>
     * @param warning_string content of the warning message
     * @param severity severity of the warning message
     *                 (accepted id = 1, 2 or 3)
     */
    public void report_warning(String warning_string,
                               int severity, int id)
            throws xMsgException, CException, SocketException {

        // build the xMsgData object
        xMsgD.Data.Builder db = xMsgD.Data.newBuilder();

        db.setSender(getName());
        db.setDataGenerationStatus(xMsgD.Data.Severity.WARNING);
        db.setDataType(xMsgD.Data.DType.T_STRING);
        db.setSTRING(warning_string);
        db.setId(id);
        db.setExecutionTime(_avEngineExecutionTime);

        genericSend("localhost",
                xMsgConstants.WARNING.getStringValue() + ":" +
                        getName() + ":" + severity,
                db);

        if(!getFeHostName().equals(xMsgConstants.UNDEFINED.getStringValue())) {
            genericSend(getFeHostName(),
                    xMsgConstants.WARNING.getStringValue() + ":" +
                            getName() + ":" + severity,
                    db);
        }
        }

    /**
     * <p>
     *    Broadcasts a xMsgData transient data
     *    containing an error-string to a
     *    topic = error:severity:this_service_canonical_name
     *    Note: that this will also send
     *    service engine execution average time.
     *
     * </p>
     * @param error_string content of the error message
     * @param severity severity level of the error message
     */
    public void report_error(String error_string,
                             int severity, int id)
            throws xMsgException, CException, SocketException {

        // build the xMsgData object
        xMsgD.Data.Builder db = xMsgD.Data.newBuilder();

        db.setSender(getName());
        db.setDataGenerationStatus(xMsgD.Data.Severity.ERROR);
        db.setDataType(xMsgD.Data.DType.T_STRING);
        db.setSTRING(error_string);
        db.setId(id);
        db.setExecutionTime(_avEngineExecutionTime);

        genericSend("localhost",
                xMsgConstants.ERROR.getStringValue() + ":" +
                        getName() + ":" + severity,
                db);
        if(!getFeHostName().equals(xMsgConstants.UNDEFINED.getStringValue())) {
            genericSend(getFeHostName(),
                    xMsgConstants.ERROR.getStringValue() + ":" +
                            getName() + ":" + severity,
                    db);
        }
    }

    /**
     *
     * @throws xMsgException
     */
    public void dispose() throws xMsgException, SocketException {
        remove_registration();

            // Send service_up message to the FE
            genericSend("localhost",
                    CConstants.SERVICE + ":" + "localhost",
                    CConstants.SERVICE_DOWN + "?" + getName());
        if(!getFeHostName().equals(xMsgConstants.UNDEFINED.getStringValue())) {
            genericSend(getFeHostName(),
                    CConstants.SERVICE + ":" + getFeHostName(),
                    CConstants.SERVICE_DOWN + "?" + getName());
        }
    }

}
